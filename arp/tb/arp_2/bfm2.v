// File: bfm.v
// Generated by MyHDL 0.11
// Date: Sun Aug  6 06:51:46 2023


`timescale 1ns/1ps

module bfm (

);



reg s_eth_hdr_ready;
reg s_eth_payload_axis_tready;
reg [47:0] m_eth_dest_mac;
reg [47:0] m_eth_src_mac;
reg [15:0] m_eth_type;
reg [0:0] m_eth_payload_axis_tkeep;
reg m_eth_payload_axis_tuser;
reg arp_request_ready;
reg arp_response_valid;
reg arp_response_error;
reg [47:0] arp_response_mac;
reg [31:0] arp_request_ip;
reg arp_request_valid;
reg arp_response_ready;
reg clear_cache;
reg clk;
reg [31:0] gateway_ip;
reg [31:0] local_ip;
reg [47:0] local_mac;
reg m_eth_hdr_ready;
reg m_eth_hdr_valid;
reg [7:0] m_eth_payload_axis_tdata;
reg m_eth_payload_axis_tlast;
reg m_eth_payload_axis_tready;
reg m_eth_payload_axis_tvalid;
reg rck;
reg rst;
reg [223:0] rx_arp_payload_data;
reg rx_en;
reg rx_state;
reg [47:0] s_eth_dest_mac;
reg s_eth_hdr_valid;
reg [7:0] s_eth_payload_axis_tdata;
reg [0:0] s_eth_payload_axis_tkeep;
reg s_eth_payload_axis_tlast;
reg s_eth_payload_axis_tuser;
reg s_eth_payload_axis_tvalid;
reg [47:0] s_eth_src_mac;
reg [15:0] s_eth_type;
reg [31:0] subnet_mask;
reg tck;
reg [223:0] tx_arp_payload_data;
reg tx_en;
reg [4:0] tx_num;
reg [335:0] tx_payload_data;
reg tx_state;



initial begin: BFM_CLKDRIVER0_DRIVE_CLK
    while (1'b1) begin
        # 4;
        clk <= 1;
        # 4;
        clk <= 0;
    end
end


always @(posedge clk, negedge clk) begin: BFM_TX_CLKDRIVER
    if (tx_en) begin
        tck <= clk;
    end
    else begin
        tck <= 0;
    end
end


always @(posedge clk, negedge clk) begin: BFM_RX_CLKDRIVER
    if (rx_en) begin
        rck <= clk;
    end
    else begin
        rck <= 0;
    end
end


initial begin: BFM_STIMULUS
    subnet_mask <= 0;
    s_eth_payload_axis_tuser <= 0;
    m_eth_hdr_ready <= 1;
    m_eth_payload_axis_tready <= 1;
    arp_request_valid <= 0;
    arp_request_ip <= 0;
    arp_response_ready <= 0;
    local_mac <= 0;
    local_ip <= 0;
    gateway_ip <= 0;
    subnet_mask <= 0;
    clear_cache <= 0;
    @(posedge clk);
end


always @(posedge tck, posedge rst) begin: BFM_ARP_TX
    if (rst) begin
        tx_en <= 0;
        s_eth_hdr_valid <= 0;
        s_eth_dest_mac <= 0;
        s_eth_src_mac <= 0;
        s_eth_type <= 0;
        tx_arp_payload_data <= 0;
        s_eth_payload_axis_tkeep <= 0;
        s_eth_payload_axis_tvalid <= 0;
        s_eth_payload_axis_tdata <= 0;
        s_eth_payload_axis_tlast <= 0;
        tx_num <= 0;
        tx_state <= 1'b0;
    end
    else begin
        case (tx_state)
            1'b0: begin
                s_eth_hdr_valid <= 1;
                s_eth_dest_mac <= tx_payload_data[336-1:(336 - 48)];
                s_eth_src_mac <= tx_payload_data[(336 - 48)-1:(336 - 96)];
                s_eth_type <= tx_payload_data[(336 - 96)-1:(336 - 112)];
                tx_arp_payload_data <= tx_payload_data[(336 - 112)-1:0];
                s_eth_payload_axis_tkeep <= 1;
                s_eth_payload_axis_tvalid <= 1;
                s_eth_payload_axis_tdata <= 0;
                tx_state <= 1'b1;
            end
            1'b1: begin
                if ((tx_num == 0)) begin
                    s_eth_hdr_valid <= 0;
                end
                if (($signed({1'b0, tx_num}) <= (28 - 1))) begin
                    s_eth_payload_axis_tdata <= tx_arp_payload_data[(336 - 112)-1:((336 - 113) - 7)];
                    tx_arp_payload_data <= (tx_arp_payload_data << 8);
                    tx_num <= (tx_num + 1);
                end
                if (($signed({1'b0, tx_num}) == (28 - 1))) begin
                    s_eth_payload_axis_tlast <= 1;
                    tx_num <= (tx_num + 1);
                end
                if ((tx_num == 28)) begin
                    s_eth_payload_axis_tlast <= 0;
                    s_eth_payload_axis_tvalid <= 0;
                    tx_num <= 0;
                    tx_state <= 1'b0;
                    tx_en <= 0;
                end
            end
            default: begin
                $finish;
            end
        endcase
    end
end


always @(posedge rck, posedge rst) begin: BFM_ARP_RX
    if (rst) begin
        rx_en <= 0;
        rx_arp_payload_data <= 0;
        rx_state <= 1'b0;
    end
    else begin
        case (rx_state)
            1'b0: begin
                if ((m_eth_hdr_valid == 1)) begin
                    rx_state <= 1'b1;
                end
            end
            1'b1: begin
                if ((m_eth_payload_axis_tvalid == 1)) begin
                    rx_arp_payload_data <= ((rx_arp_payload_data << 8) + m_eth_payload_axis_tdata);
                end
                if ((m_eth_payload_axis_tlast == 1)) begin
                    rx_state <= 1'b0;
                    rx_en <= 0;
                end
            end
            default: begin
                $finish;
            end
        endcase
    end
end


arp dut(
    clk,
    rst,
    s_eth_hdr_valid,
    s_eth_hdr_ready,
    s_eth_dest_mac,
    s_eth_src_mac,
    s_eth_type,
    s_eth_payload_axis_tdata,
    s_eth_payload_axis_tkeep,
    s_eth_payload_axis_tvalid,
    s_eth_payload_axis_tready,
    s_eth_payload_axis_tlast,
    s_eth_payload_axis_tuser,
    m_eth_hdr_valid,
    m_eth_hdr_ready,
    m_eth_dest_mac,
    m_eth_src_mac,
    m_eth_type,
    m_eth_payload_axis_tdata,
    m_eth_payload_axis_tkeep,
    m_eth_payload_axis_tvalid,
    m_eth_payload_axis_tready,
    m_eth_payload_axis_tlast,
    m_eth_payload_axis_tuser,
    arp_request_valid,
    arp_request_ready,
    arp_request_ip,
    arp_response_valid,
    arp_response_ready,
    arp_response_error,
    arp_response_mac,
    local_mac,
    local_ip,
    gateway_ip,
    subnet_mask,
    clear_cache
);

endmodule
